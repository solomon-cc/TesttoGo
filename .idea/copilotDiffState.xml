<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/INITIAL.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/INITIAL.md" />
              <option name="originalContent" value="# ARCHITECTURE_DECISION_RECORD.md&#10;&#10;## 项目名称：Golang 在线题库测试系统&#10;## 文档版本：v1.1&#10;## 创建日期：2025-08-06&#10;## 作者：任玉军&#10;&#10;---&#10;&#10;## 一、项目背景与目标&#10;&#10;本项目旨在开发一套基于 Golang 的在线题库系统，支持选择题、判断题、填空题、加减法题等题型，提供用户注册、登录与答题功能，用户分为：普通用户、老师和管理员。&#10;&#10;目标包括：&#10;- 支持多种题型，包括含图、语音、视频题&#10;- 支持题目标签、难度分级机制，便于分类筛选&#10;- 教师可管理题目、组卷，学生答题并查看成绩&#10;- 管理员具有用户和题库的管理权限&#10;- 前后端解耦，RESTful API 设计，支持移动端或 Web 前端调用&#10;&#10;---&#10;&#10;## 二、系统架构设计&#10;&#10;### 2.1 架构概览&#10;&#10;```text&#10;[客户端] ⇄ [Gin API 网关] ⇄ [服务层] ⇄ [GORM + MySQL 数据库]&#10;                              ⇄ [JWT Auth]&#10;                              ⇄ [文件服务：本地/OSS]&#10;```&#10;&#10;### 2.2 模块划分&#10;&#10;| 模块名称     | 描述 |&#10;|--------------|------|&#10;| 用户模块     | 注册、登录、鉴权、角色控制 |&#10;| 题库模块     | 创建题目、题型支持、图片/语音/视频上传 |&#10;| 分类模块     | 标签与难度管理 |&#10;| 组卷模块     | 教师可创建试卷、自定义题目组合 |&#10;| 答题模块     | 随机出题/按卷答题、答题记录、自动评分 |&#10;| 权限模块     | 用户权限验证（JWT + Role） |&#10;| 管理模块     | 用户、题目、试卷管理等 |&#10;&#10;---&#10;&#10;## 三、技术选型&#10;&#10;| 组件         | 技术或方案           | 理由 |&#10;|--------------|----------------------|------|&#10;| Web 框架     | Gin                  | 高性能，轻量 REST API 支持 |&#10;| ORM          | GORM                 | Golang 主流 ORM，开发效率高 |&#10;| 数据库       | MySQL                | 结构化数据稳定支持 |&#10;| 配置管理     | Viper                | 支持多环境配置 |&#10;| 鉴权         | JWT + Middleware     | 无状态鉴权，适合 REST API |&#10;| 密码加密     | bcrypt               | 安全标准，防止明文泄漏 |&#10;| 文件上传     | 本地存储 or OSS | 支持图片、语音、视频题目资源 |&#10;| 测试工具     | Postman / Go test    | API 测试与单元测试 |&#10;&#10;---&#10;&#10;## 四、目录结构约定&#10;&#10;```bash&#10;online-quiz/&#10;├── api/                  # 路由与请求绑定&#10;├── internal/&#10;│   ├── controller/&#10;│   ├── service/&#10;│   ├── dao/&#10;│   ├── model/&#10;│   │   ├── entity/&#10;│   │   └── request/&#10;│   └── middleware/&#10;├── pkg/                  # 公共库&#10;├── config/               # 配置文件&#10;├── resource/             # 静态资源（如图片、音频、视频）&#10;├── main.go&#10;```&#10;&#10;---&#10;&#10;## 五、数据模型设计（MySQL）&#10;&#10;### 5.1 用户表 `users`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| username     | VARCHAR(50) | 用户名，唯一 |&#10;| password     | VARCHAR(255)| 加密后的密码 |&#10;| role         | ENUM        | 'user' | 'teacher' | 'admin' |&#10;| created_at   | DATETIME    | 创建时间 |&#10;| updated_at   | DATETIME    | 更新时间 |&#10;&#10;### 5.2 题目表 `questions`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| title        | TEXT        | 题干内容 |&#10;| type         | ENUM        | 'choice', 'judge', 'blank', 'math', 'audio', 'video' |&#10;| media_url    | TEXT        | 题目相关音频/视频资源 |&#10;| image_url    | TEXT        | 图片地址（可为空） |&#10;| options      | JSON        | 仅 choice 类型使用 |&#10;| answer       | TEXT        | 正确答案 |&#10;| difficulty   | ENUM        | 'easy', 'medium', 'hard' |&#10;| tags         | JSON        | 标签列表（如：[&quot;语文&quot;, &quot;识图&quot;]）|&#10;| created_by   | BIGINT      | 外键：users.id |&#10;| created_at   | DATETIME    | 创建时间 |&#10;&#10;### 5.3 答题记录表 `answers`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| user_id      | BIGINT      | 外键：用户 |&#10;| question_id  | BIGINT      | 外键：题目 |&#10;| user_answer  | TEXT        | 用户提交的答案 |&#10;| is_correct   | BOOLEAN     | 是否正确 |&#10;| answered_at  | DATETIME    | 提交时间 |&#10;&#10;### 5.4 试卷表 `papers`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| name         | VARCHAR(100)| 试卷名称 |&#10;| description  | TEXT        | 描述信息 |&#10;| created_by   | BIGINT      | 外键：users.id（教师） |&#10;| created_at   | DATETIME    | 创建时间 |&#10;&#10;### 5.5 试卷题目关联表 `paper_questions`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| paper_id     | BIGINT      | 所属试卷 |&#10;| question_id  | BIGINT      | 所含题目 |&#10;&#10;---&#10;&#10;## 六、接口设计（新增内容）&#10;&#10;### 6.1 题目分类相关&#10;&#10;- **GET /api/tags**  &#10;  获取所有题目标签&#10;&#10;- **GET /api/questions?tags=数学&amp;difficulty=medium**  &#10;  按标签和难度筛选题目&#10;&#10;---&#10;&#10;### 6.2 媒体资源支持&#10;&#10;- **POST /api/upload**  &#10;  上传图片、语音、视频文件，返回 `media_url` 或 `image_url`&#10;&#10;---&#10;&#10;### 6.3 组卷系统（教师专属）&#10;&#10;- **POST /api/papers**  &#10;  创建试卷（填写名称、描述）&#10;&#10;- **POST /api/papers/{id}/add_question**  &#10;  向试卷中添加题目&#10;&#10;- **GET /api/papers**  &#10;  查看教师创建的试卷&#10;&#10;- **GET /api/papers/{id}/questions**  &#10;  查看试卷内题目列表&#10;&#10;- **POST /api/paper/{id}/submit**  &#10;  学生提交整卷答案&#10;&#10;---&#10;&#10;## 七、安全与权限设计&#10;&#10;- 所有接口使用 JWT 认证中间件&#10;- 路由权限按角色控制：&#10;    - 用户：答题、查看成绩、按试卷答题&#10;    - 教师：管理题库、组卷、发布考试&#10;    - 管理员：全面管理用户、题库、试卷&#10;&#10;---&#10;&#10;## 八、后续拓展建议&#10;&#10;- 实时考试模式（定时 + WebSocket 监控）&#10;- 成绩统计、导出功能&#10;- 视频防作弊（WebRTC 实时画面）&#10;- 标签推荐系统（基于用户行为）&#10;&#10;---&#10;&#10;## 九、部署建议&#10;&#10;- 使用 Docker Compose 管理数据库与服务&#10;- 本地资源支持 Nginx 或对象存储挂载&#10;- 使用 systemd 管理服务进程&#10;- 生产环境配置自动分离（viper + .env）&#10;&#10;---&#10;&#10;## 十、变更记录&#10;&#10;| 版本 | 日期       | 修改内容                      |&#10;|------|------------|-------------------------------|&#10;| v1.0 | 2025-08-06 | 初始版本                      |&#10;| v1.1 | 2025-08-06 | 添加题目标签/难度/组卷/媒体题 |&#10;" />
              <option name="updatedContent" value="# ARCHITECTURE_DECISION_RECORD.md&#10;&#10;## 项目名称：Golang 在线题库测试系统&#10;## 文档版本：v1.1&#10;## 创建日期：2025-08-06&#10;## 作者：任玉军&#10;&#10;---&#10;&#10;## 一、项目背景与目标&#10;&#10;本项目旨在开发一套基于 Golang 的在线题库系统，支持选择题、判断题、填空题、加减法题等题型，提供用户注册、登录与答题功能，用户分为：普通用户、老师和管理员。&#10;&#10;目标包括：&#10;- 支持多种题型，包括含图、语音、视频题&#10;- 支持题目标签、难度分级机制，便于分类筛选&#10;- 教师可管理题目、组卷，学生答题并查看成绩&#10;- 管理员具有用户和题库的管理权限&#10;- 前后端解耦，RESTful API 设计，支持移动端或 Web 前端调用&#10;&#10;---&#10;&#10;## 二、系统架构设计&#10;&#10;### 2.1 架构概览&#10;&#10;```text&#10;[客户端] ⇄ [Gin API 网关] ⇄ [服务层] ⇄ [GORM + MySQL 数据库]&#10;                              ⇄ [JWT Auth]&#10;                              ⇄ [文件服务：本地/OSS]&#10;```&#10;&#10;### 2.2 模块划分&#10;&#10;| 模块名称     | 描述 |&#10;|--------------|------|&#10;| 用户模块     | 注册、登录、鉴权、角色控制 |&#10;| 题库模块     | 创建题目、题型支持、图片/语音/视频上传 |&#10;| 分类模块     | 标签与难度管理 |&#10;| 组卷模块     | 教师可创建试卷、自定义题目组合 |&#10;| 答题模块     | 随机出题/按卷答题、答题记录、自动评分 |&#10;| 权限模块     | 用户权限验证（JWT + Role） |&#10;| 管理模块     | 用户、题目、试卷管理等 |&#10;&#10;---&#10;&#10;## 三、技术选型&#10;&#10;| 组件         | 技术或方案           | 理由 |&#10;|--------------|----------------------|------|&#10;| Web 框架     | Gin                  | 高性能，轻量 REST API 支持 |&#10;| ORM          | GORM                 | Golang 主流 ORM，开发效率高 |&#10;| 数据库       | MySQL                | 结构化数据稳定支持 |&#10;| 配置管理     | Viper                | 支持多环境配置 |&#10;| 鉴权         | JWT + Middleware     | 无状态鉴权，适合 REST API |&#10;| 密码加密     | bcrypt               | 安全标准，防止明文泄漏 |&#10;| 文件上传     | 本地存储 or OSS | 支持图片、语音、视频题目资源 |&#10;| 测试工具     | Postman / Go test    | API 测试与单元测试 |&#10;&#10;---&#10;&#10;## 四、目录结构约定&#10;&#10;```bash&#10;online-quiz/&#10;├── api/                  # 路由与请求绑定&#10;├── internal/&#10;│   ├── controller/&#10;│   ├── service/&#10;│   ├── dao/&#10;│   ├── model/&#10;│   │   ├── entity/&#10;│   │   └── request/&#10;│   └── middleware/&#10;├── pkg/                  # 公共库&#10;├── config/               # 配置文件&#10;├── resource/             # 静态资源（如图片、音频、视频）&#10;├── main.go&#10;```&#10;&#10;---&#10;&#10;## 五、数据模型设计（MySQL）&#10;&#10;### 5.1 用户表 `users`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| username     | VARCHAR(50) | 用户名，唯一 |&#10;| password     | VARCHAR(255)| 加密后的密码 |&#10;| role         | ENUM        | 'user' | 'teacher' | 'admin' |&#10;| created_at   | DATETIME    | 创建时间 |&#10;| updated_at   | DATETIME    | 更新时间 |&#10;&#10;### 5.2 题目表 `questions`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| title        | TEXT        | 题干内容 |&#10;| type         | ENUM        | 'choice', 'judge', 'blank', 'math', 'audio', 'video' |&#10;| media_url    | TEXT        | 题目相关音频/视频资源 |&#10;| image_url    | TEXT        | 图片地址（可为空） |&#10;| options      | JSON        | 仅 choice 类型使用 |&#10;| answer       | TEXT        | 正确答案 |&#10;| difficulty   | ENUM        | 'easy', 'medium', 'hard' |&#10;| tags         | JSON        | 标签列表（如：[&quot;语文&quot;, &quot;识图&quot;]）|&#10;| created_by   | BIGINT      | 外键：users.id |&#10;| created_at   | DATETIME    | 创建时间 |&#10;&#10;### 5.3 答题记录表 `answers`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| user_id      | BIGINT      | 外键：用户 |&#10;| question_id  | BIGINT      | 外键：题目 |&#10;| user_answer  | TEXT        | 用户提交的答案 |&#10;| is_correct   | BOOLEAN     | 是否正确 |&#10;| answered_at  | DATETIME    | 提交时间 |&#10;&#10;### 5.4 试卷表 `papers`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| name         | VARCHAR(100)| 试卷名称 |&#10;| description  | TEXT        | 描述信息 |&#10;| created_by   | BIGINT      | 外键：users.id（教师） |&#10;| created_at   | DATETIME    | 创建时间 |&#10;&#10;### 5.5 试卷题目关联表 `paper_questions`&#10;&#10;| 字段名       | 类型        | 说明 |&#10;|--------------|-------------|------|&#10;| id           | BIGINT      | 主键 |&#10;| paper_id     | BIGINT      | 所属试卷 |&#10;| question_id  | BIGINT      | 所含题目 |&#10;&#10;---&#10;&#10;## 六、接口设计（新增内容）&#10;&#10;### 6.1 题目分类相关&#10;&#10;- **GET /api/tags**  &#10;  获取所有题目标签&#10;&#10;- **GET /api/questions?tags=数学&amp;difficulty=medium**  &#10;  按标签和难度筛选题目&#10;&#10;---&#10;&#10;### 6.2 媒体资源支持&#10;&#10;- **POST /api/upload**  &#10;  上传图片、语音、视频文件，返回 `media_url` 或 `image_url`&#10;&#10;---&#10;&#10;### 6.3 组卷系统（教师专属）&#10;&#10;- **POST /api/papers**  &#10;  创建试卷（填写名称、描述）&#10;&#10;- **POST /api/papers/{id}/add_question**  &#10;  向试卷中添加题目&#10;&#10;- **GET /api/papers**  &#10;  查看教师创建的试卷&#10;&#10;- **GET /api/papers/{id}/questions**  &#10;  查看试卷内题目列表&#10;&#10;- **POST /api/paper/{id}/submit**  &#10;  学生提交整卷答案&#10;&#10;---&#10;&#10;## 七、安全与权限设计&#10;&#10;- 所有接口使用 JWT 认证中间件&#10;- 路由权限按角色控制：&#10;    - 用户：答题、查看成绩、按试卷答题&#10;    - 教师：管理题库、组卷、发布考试&#10;    - 管理员：全面管理用户、题库、试卷&#10;&#10;---&#10;&#10;## 八、后续拓展建议&#10;&#10;- 实时考试模式（定时 + WebSocket 监控）&#10;- 成绩统计、导出功能&#10;- 视频防作弊（WebRTC 实时画面）&#10;- 标签推荐系统（基于用户行为）&#10;&#10;---&#10;&#10;## 九、部署建议&#10;&#10;- 使用 Docker Compose 管理数据库与服务&#10;- 本地资源支持 Nginx 或对象存储挂载&#10;- 使用 systemd 管理服务进程&#10;- 生产环境配置自动分离（viper + .env）&#10;&#10;---&#10;&#10;## 十、变更记录&#10;&#10;| 版本 | 日期       | 修改内容                      |&#10;|------|------------|-------------------------------|&#10;| v1.0 | 2025-08-06 | 初始版本                      |&#10;| v1.1 | 2025-08-06 | 添加题目标签/难度/组卷/媒体题 |&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/config/config.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/config/config.yml" />
              <option name="updatedContent" value="server:&#10;  port: &quot;8080&quot;&#10;  mode: &quot;debug&quot;&#10;&#10;database:&#10;  driver: &quot;mysql&quot;&#10;  host: &quot;localhost&quot;&#10;  port: 3306&#10;  username: &quot;root&quot;&#10;  password: &quot;123456&quot;&#10;  dbname: &quot;testogo&quot;&#10;  charset: &quot;utf8mb4&quot;&#10;  maxIdleConns: 10&#10;  maxOpenConns: 100&#10;&#10;jwt:&#10;  secret: &quot;your-secret-key&quot;&#10;  expire: 24  # hours&#10;&#10;upload:&#10;  savePath: &quot;./resource&quot;&#10;  maxSize: 10 # MB" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/go.mod">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/go.mod" />
              <option name="updatedContent" value="module testogo&#10;&#10;go 1.21&#10;&#10;require (&#10;&#9;github.com/gin-gonic/gin v1.9.1&#10;&#9;github.com/golang-jwt/jwt/v5 v5.0.0&#10;&#9;github.com/spf13/viper v1.16.0&#10;&#9;golang.org/x/crypto v0.9.0&#10;&#9;gorm.io/driver/mysql v1.5.1&#10;&#9;gorm.io/gorm v1.25.4&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/controller/auth.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/controller/auth.go" />
              <option name="updatedContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;testogo/internal/middleware&quot;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#9;&quot;testogo/internal/model/request&quot;&#10;&#9;&quot;testogo/pkg/database&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;golang.org/x/crypto/bcrypt&quot;&#10;)&#10;&#10;func Register(c *gin.Context) {&#10;&#9;var req request.RegisterRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 检查用户名是否已存在&#10;&#9;var existingUser entity.User&#10;&#9;result := database.DB.Where(&quot;username = ?&quot;, req.Username).First(&amp;existingUser)&#10;&#9;if result.RowsAffected &gt; 0 {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;用户名已存在&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 密码加密&#10;&#9;hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;密码加密失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 创建新用户&#10;&#9;user := entity.User{&#10;&#9;&#9;Username: req.Username,&#10;&#9;&#9;Password: string(hashedPassword),&#10;&#9;&#9;Role:     entity.RoleUser,&#10;&#9;}&#10;&#10;&#9;if err := database.DB.Create(&amp;user).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;创建用户失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;注册成功&quot;})&#10;}&#10;&#10;func Login(c *gin.Context) {&#10;&#9;var req request.LoginRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var user entity.User&#10;&#9;result := database.DB.Where(&quot;username = ?&quot;, req.Username).First(&amp;user)&#10;&#9;if result.Error != nil {&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;用户名或密码错误&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 验证密码&#10;&#9;if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password)); err != nil {&#10;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;用户名或密码错误&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 生成 JWT token&#10;&#9;token, err := middleware.GenerateToken(user.ID, string(user.Role))&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;生成token失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, request.LoginResponse{&#10;&#9;&#9;Token: token,&#10;&#9;&#9;Role:  string(user.Role),&#10;&#9;})&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/controller/paper.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/controller/paper.go" />
              <option name="originalContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#9;&quot;testogo/internal/model/request&quot;&#10;&#9;&quot;testogo/pkg/database&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;func CreatePaper(c *gin.Context) {&#10;&#9;var req request.CreatePaperRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 验证题目是否存在&#10;&#9;var count int64&#10;&#9;database.DB.Model(&amp;entity.Question{}).Where(&quot;id IN ?&quot;, req.QuestionIDs).Count(&amp;count)&#10;&#9;if int(count) != len(req.QuestionIDs) {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;包含不存在的题目&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 将题目ID列表转换为JSON字符串&#10;&#9;questionIDs, err := json.Marshal(req.QuestionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;题目列表序列化失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;paper := entity.Paper{&#10;&#9;&#9;Title:     req.Title,&#10;&#9;&#9;CreatorID: c.GetUint(&quot;userID&quot;),&#10;&#9;&#9;Questions: string(questionIDs),&#10;&#9;&#9;Duration:  req.Duration,&#10;&#9;}&#10;&#10;&#9;if err := database.DB.Create(&amp;paper).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;创建试卷失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;id&quot;: paper.ID})&#10;}&#10;&#10;func GetPaper(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var paper entity.Paper&#10;&#9;if err := database.DB.First(&amp;paper, id).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;试卷不存在&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 解析题目ID列表&#10;&#9;var questionIDs []uint&#10;&#9;if err := json.Unmarshal([]byte(paper.Questions), &amp;questionIDs); err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;解析题目列表失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 获取题目详情&#10;&#9;var questions []entity.Question&#10;&#9;if err := database.DB.Find(&amp;questions, questionIDs).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取题目详情失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;id&quot;:        paper.ID,&#10;&#9;&#9;&quot;title&quot;:     paper.Title,&#10;&#9;&#9;&quot;duration&quot;:  paper.Duration,&#10;&#9;&#9;&quot;questions&quot;: questions,&#10;&#9;})&#10;}&#10;&#10;func SubmitPaper(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;paperID, err := strconv.ParseUint(id, 10, 32)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;无效的试卷ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var answers []request.SubmitAnswerRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;answers); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;userID := c.GetUint(&quot;userID&quot;)&#10;&#9;var totalScore int&#10;&#10;&#9;// 开启事务&#10;&#9;tx := database.DB.Begin()&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;for _, answer := range answers {&#10;&#9;&#9;// 获取题目信息&#10;&#9;&#9;var question entity.Question&#10;&#9;&#9;if err := tx.First(&amp;question, answer.QuestionID).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;题目不存在&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 计算得分&#10;&#9;&#9;score := 0&#10;&#9;&#9;if question.Answer == answer.Answer {&#10;&#9;&#9;&#9;score = 10 // 每题10分&#10;&#9;&#9;}&#10;&#9;&#9;totalScore += score&#10;&#10;&#9;&#9;// 保存答题记录&#10;&#9;&#9;userAnswer := entity.UserAnswer{&#10;&#9;&#9;&#9;UserID:     userID,&#10;&#9;&#9;&#9;PaperID:    answer.PaperID,&#10;&#9;&#9;&#9;QuestionID: answer.QuestionID,&#10;&#9;&#9;&#9;Answer:     answer.Answer,&#10;&#9;&#9;&#9;Score:      score,&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := tx.Create(&amp;userAnswer).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;保存答题记录失败&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err := tx.Commit().Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;提交试卷失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;提交成功&quot;,&#10;&#9;&#9;&quot;score&quot;:   totalScore,&#10;&#9;})&#10;}&#10;&#10;func GetPaperResult(c *gin.Context) {&#10;&#9;paperID := c.Param(&quot;id&quot;)&#10;&#9;userID := c.GetUint(&quot;userID&quot;)&#10;&#10;&#9;var answers []entity.UserAnswer&#10;&#9;if err := database.DB.Where(&quot;user_id = ? AND paper_id = ?&quot;, userID, paperID).Find(&amp;answers).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取答题记录失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;totalScore := 0&#10;&#9;for _, answer := range answers {&#10;&#9;&#9;totalScore += answer.Score&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;answers&quot;:    answers,&#10;&#9;&#9;&quot;totalScore&quot;: totalScore,&#10;&#9;})&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#9;&quot;testogo/internal/model/request&quot;&#10;&#9;&quot;testogo/pkg/database&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;func CreatePaper(c *gin.Context) {&#10;&#9;var req request.CreatePaperRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 验证题目是否存在&#10;&#9;var count int64&#10;&#9;database.DB.Model(&amp;entity.Question{}).Where(&quot;id IN ?&quot;, req.QuestionIDs).Count(&amp;count)&#10;&#9;if int(count) != len(req.QuestionIDs) {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;包含不存在的题目&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 将题目ID列表转换为JSON字符串&#10;&#9;questionIDs, err := json.Marshal(req.QuestionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;题目列表序列化失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;paper := entity.Paper{&#10;&#9;&#9;Title:     req.Title,&#10;&#9;&#9;CreatorID: c.GetUint(&quot;userID&quot;),&#10;&#9;&#9;Questions: string(questionIDs),&#10;&#9;&#9;Duration:  req.Duration,&#10;&#9;}&#10;&#10;&#9;if err := database.DB.Create(&amp;paper).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;创建试卷失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;id&quot;: paper.ID})&#10;}&#10;&#10;func GetPaper(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var paper entity.Paper&#10;&#9;if err := database.DB.First(&amp;paper, id).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;试卷不存在&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 解析题目ID列表&#10;&#9;var questionIDs []uint&#10;&#9;if err := json.Unmarshal([]byte(paper.Questions), &amp;questionIDs); err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;解析题目列表失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 获取题目详情&#10;&#9;var questions []entity.Question&#10;&#9;if err := database.DB.Find(&amp;questions, questionIDs).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取题目详情失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;id&quot;:        paper.ID,&#10;&#9;&#9;&quot;title&quot;:     paper.Title,&#10;&#9;&#9;&quot;duration&quot;:  paper.Duration,&#10;&#9;&#9;&quot;questions&quot;: questions,&#10;&#9;})&#10;}&#10;&#10;func SubmitPaper(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;paperID, err := strconv.ParseUint(id, 10, 32)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;无效的试卷ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var answers []request.SubmitAnswerRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;answers); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;userID := c.GetUint(&quot;userID&quot;)&#10;&#9;var totalScore int&#10;&#10;&#9;// 开启事务&#10;&#9;tx := database.DB.Begin()&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;for _, answer := range answers {&#10;&#9;&#9;// 获取题目信息&#10;&#9;&#9;var question entity.Question&#10;&#9;&#9;if err := tx.First(&amp;question, answer.QuestionID).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;题目不存在&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 计算得分&#10;&#9;&#9;score := 0&#10;&#9;&#9;if question.Answer == answer.Answer {&#10;&#9;&#9;&#9;score = 10 // 每题10分&#10;&#9;&#9;}&#10;&#9;&#9;totalScore += score&#10;&#10;&#9;&#9;// 保存答题记录&#10;&#9;&#9;userAnswer := entity.UserAnswer{&#10;&#9;&#9;&#9;UserID:     userID,&#10;&#9;&#9;&#9;PaperID:    uint(paperID),&#10;&#9;&#9;&#9;QuestionID: answer.QuestionID,&#10;&#9;&#9;&#9;Answer:     answer.Answer,&#10;&#9;&#9;&#9;Score:      score,&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := tx.Create(&amp;userAnswer).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;保存答题记录失败&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err := tx.Commit().Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;提交试卷失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;提交成功&quot;,&#10;&#9;&#9;&quot;score&quot;:   totalScore,&#10;&#9;})&#10;}&#10;&#10;func GetPaperResult(c *gin.Context) {&#10;&#9;paperID := c.Param(&quot;id&quot;)&#10;&#9;userID := c.GetUint(&quot;userID&quot;)&#10;&#10;&#9;var answers []entity.UserAnswer&#10;&#9;if err := database.DB.Where(&quot;user_id = ? AND paper_id = ?&quot;, userID, paperID).Find(&amp;answers).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取答题记录失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;totalScore := 0&#10;&#9;for _, answer := range answers {&#10;&#9;&#9;totalScore += answer.Score&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;answers&quot;:    answers,&#10;&#9;&#9;&quot;totalScore&quot;: totalScore,&#10;&#9;})&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/controller/question.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/controller/question.go" />
              <option name="updatedContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#9;&quot;testogo/internal/model/request&quot;&#10;&#9;&quot;testogo/pkg/database&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;func CreateQuestion(c *gin.Context) {&#10;&#9;var req request.CreateQuestionRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;userID := c.GetUint(&quot;userID&quot;)&#10;&#9;question := entity.Question{&#10;&#9;&#9;Title:       req.Title,&#10;&#9;&#9;Type:        entity.QuestionType(req.Type),&#10;&#9;&#9;Difficulty:  req.Difficulty,&#10;&#9;&#9;Options:     req.Options,&#10;&#9;&#9;Answer:      req.Answer,&#10;&#9;&#9;Explanation: req.Explanation,&#10;&#9;&#9;CreatorID:   userID,&#10;&#9;&#9;Tags:        req.Tags,&#10;&#9;}&#10;&#10;&#9;if err := database.DB.Create(&amp;question).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;创建题目失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;id&quot;: question.ID})&#10;}&#10;&#10;func ListQuestions(c *gin.Context) {&#10;&#9;var questions []entity.Question&#10;&#9;query := database.DB.Order(&quot;id desc&quot;)&#10;&#10;&#9;// 支持按类型和难度过滤&#10;&#9;if qType := c.Query(&quot;type&quot;); qType != &quot;&quot; {&#10;&#9;&#9;query = query.Where(&quot;type = ?&quot;, qType)&#10;&#9;}&#10;&#9;if difficulty := c.Query(&quot;difficulty&quot;); difficulty != &quot;&quot; {&#10;&#9;&#9;query = query.Where(&quot;difficulty = ?&quot;, difficulty)&#10;&#9;}&#10;&#10;&#9;// 分页&#10;&#9;page, _ := strconv.Atoi(c.DefaultQuery(&quot;page&quot;, &quot;1&quot;))&#10;&#9;pageSize, _ := strconv.Atoi(c.DefaultQuery(&quot;page_size&quot;, &quot;10&quot;))&#10;&#9;var total int64&#10;&#9;database.DB.Model(&amp;entity.Question{}).Count(&amp;total)&#10;&#10;&#9;err := query.Offset((page - 1) * pageSize).Limit(pageSize).Find(&amp;questions).Error&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取题目列表失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;total&quot;: total,&#10;&#9;&#9;&quot;items&quot;: questions,&#10;&#9;})&#10;}&#10;&#10;func GetQuestion(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var question entity.Question&#10;&#9;if err := database.DB.First(&amp;question, id).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;题目不存在&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;c.JSON(http.StatusOK, question)&#10;}&#10;&#10;func UpdateQuestion(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var req request.UpdateQuestionRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var question entity.Question&#10;&#9;if err := database.DB.First(&amp;question, id).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;题目不存在&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 更新题目信息&#10;&#9;updates := map[string]interface{}{&#10;&#9;&#9;&quot;title&quot;:       req.Title,&#10;&#9;&#9;&quot;difficulty&quot;:  req.Difficulty,&#10;&#9;&#9;&quot;options&quot;:     req.Options,&#10;&#9;&#9;&quot;answer&quot;:      req.Answer,&#10;&#9;&#9;&quot;explanation&quot;: req.Explanation,&#10;&#9;&#9;&quot;tags&quot;:        req.Tags,&#10;&#9;}&#10;&#10;&#9;if err := database.DB.Model(&amp;question).Updates(updates).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;更新题目失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;更新成功&quot;})&#10;}&#10;&#10;func DeleteQuestion(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;if err := database.DB.Delete(&amp;entity.Question{}, id).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;删除题目失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;删除成功&quot;})&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/controller/user.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/controller/user.go" />
              <option name="updatedContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#9;&quot;testogo/pkg/database&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;func ListUsers(c *gin.Context) {&#10;&#9;var users []entity.User&#10;&#9;query := database.DB.Order(&quot;id desc&quot;)&#10;&#10;&#9;// 分页&#10;&#9;page, _ := strconv.Atoi(c.DefaultQuery(&quot;page&quot;, &quot;1&quot;))&#10;&#9;pageSize, _ := strconv.Atoi(c.DefaultQuery(&quot;page_size&quot;, &quot;10&quot;))&#10;&#9;var total int64&#10;&#9;database.DB.Model(&amp;entity.User{}).Count(&amp;total)&#10;&#10;&#9;err := query.Select(&quot;id, username, role, created_at, updated_at&quot;).&#10;&#9;&#9;Offset((page - 1) * pageSize).&#10;&#9;&#9;Limit(pageSize).&#10;&#9;&#9;Find(&amp;users).Error&#10;&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取用户列表失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;total&quot;: total,&#10;&#9;&#9;&quot;items&quot;: users,&#10;&#9;})&#10;}&#10;&#10;func UpdateUserRole(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var input struct {&#10;&#9;&#9;Role string `json:&quot;role&quot; binding:&quot;required,oneof=user teacher admin&quot;`&#10;&#9;}&#10;&#9;if err := c.ShouldBindJSON(&amp;input); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 检查用户是否存在&#10;&#9;var user entity.User&#10;&#9;if err := database.DB.First(&amp;user, id).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;用户不存在&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 更新用户角色&#10;&#9;if err := database.DB.Model(&amp;user).Update(&quot;role&quot;, input.Role).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;更新用户角色失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;更新成功&quot;})&#10;}&#10;&#10;func DeleteUser(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;&#10;&#9;// 检查用户是否存在&#10;&#9;var user entity.User&#10;&#9;if err := database.DB.First(&amp;user, id).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;用户不存在&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 不允许删除管理员账户&#10;&#9;if user.Role == entity.RoleAdmin {&#10;&#9;&#9;c.JSON(http.StatusForbidden, gin.H{&quot;error&quot;: &quot;不能删除管理员账户&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;if err := database.DB.Delete(&amp;user).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;删除用户失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;删除成功&quot;})&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/middleware/auth.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/middleware/auth.go" />
              <option name="updatedContent" value="package middleware&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;testogo/pkg/config&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;&#9;&quot;github.com/golang-jwt/jwt/v5&quot;&#10;)&#10;&#10;type Claims struct {&#10;&#9;UserID uint   `json:&quot;user_id&quot;`&#10;&#9;Role   string `json:&quot;role&quot;`&#10;&#9;jwt.RegisteredClaims&#10;}&#10;&#10;func GenerateToken(userID uint, role string) (string, error) {&#10;&#9;claims := Claims{&#10;&#9;&#9;UserID: userID,&#10;&#9;&#9;Role:   role,&#10;&#9;&#9;RegisteredClaims: jwt.RegisteredClaims{&#10;&#9;&#9;&#9;ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour * time.Duration(config.GetInt(&quot;jwt.expire&quot;)))),&#10;&#9;&#9;&#9;IssuedAt:  jwt.NewNumericDate(time.Now()),&#10;&#9;&#9;},&#10;&#9;}&#10;&#10;&#9;token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)&#10;&#9;return token.SignedString([]byte(config.GetString(&quot;jwt.secret&quot;)))&#10;}&#10;&#10;func AuthMiddleware() gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;auth := c.GetHeader(&quot;Authorization&quot;)&#10;&#9;&#9;if auth == &quot;&quot; {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;未提供认证信息&quot;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;token := strings.TrimPrefix(auth, &quot;Bearer &quot;)&#10;&#9;&#9;claims := &amp;Claims{}&#10;&#10;&#9;&#9;tkn, err := jwt.ParseWithClaims(token, claims, func(t *jwt.Token) (interface{}, error) {&#10;&#9;&#9;&#9;return []byte(config.GetString(&quot;jwt.secret&quot;)), nil&#10;&#9;&#9;})&#10;&#10;&#9;&#9;if err != nil || !tkn.Valid {&#10;&#9;&#9;&#9;c.JSON(http.StatusUnauthorized, gin.H{&quot;error&quot;: &quot;无效的令牌&quot;})&#10;&#9;&#9;&#9;c.Abort()&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;c.Set(&quot;userID&quot;, claims.UserID)&#10;&#9;&#9;c.Set(&quot;role&quot;, claims.Role)&#10;&#9;&#9;c.Next()&#10;&#9;}&#10;}&#10;&#10;func RoleMiddleware(roles ...string) gin.HandlerFunc {&#10;&#9;return func(c *gin.Context) {&#10;&#9;&#9;role := c.GetString(&quot;role&quot;)&#10;&#9;&#9;for _, r := range roles {&#10;&#9;&#9;&#9;if r == role {&#10;&#9;&#9;&#9;&#9;c.Next()&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;c.JSON(http.StatusForbidden, gin.H{&quot;error&quot;: &quot;权限不足&quot;})&#10;&#9;&#9;c.Abort()&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/model/entity/question.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/model/entity/question.go" />
              <option name="updatedContent" value="package entity&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type QuestionType string&#10;&#10;const (&#10;&#9;TypeChoice   QuestionType = &quot;choice&quot;   // 选择题&#10;&#9;TypeJudge    QuestionType = &quot;judge&quot;    // 判断题&#10;&#9;TypeFillIn   QuestionType = &quot;fillin&quot;   // 填空题&#10;&#9;TypeMath     QuestionType = &quot;math&quot;     // 加减法题&#10;)&#10;&#10;type Question struct {&#10;&#9;ID          uint           `gorm:&quot;primarykey&quot; json:&quot;id&quot;`&#10;&#9;Title       string         `gorm:&quot;type:text&quot; json:&quot;title&quot;`&#10;&#9;Type        QuestionType   `gorm:&quot;type:varchar(20)&quot; json:&quot;type&quot;`&#10;&#9;Difficulty  int            `gorm:&quot;type:tinyint;default:1&quot; json:&quot;difficulty&quot;` // 1-5&#10;&#9;Options     string         `gorm:&quot;type:text&quot; json:&quot;options&quot;`                 // JSON格式存储选项&#10;&#9;Answer      string         `gorm:&quot;type:text&quot; json:&quot;answer&quot;`&#10;&#9;Explanation string         `gorm:&quot;type:text&quot; json:&quot;explanation&quot;`             // 答案解释&#10;&#9;CreatorID   uint          `json:&quot;creator_id&quot;`&#10;&#9;MediaURL    string         `gorm:&quot;type:varchar(255)&quot; json:&quot;media_url&quot;`      // 媒体资源URL&#10;&#9;Tags        string         `gorm:&quot;type:varchar(255)&quot; json:&quot;tags&quot;`           // 逗号分隔的标签&#10;&#9;CreatedAt   time.Time      `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt   time.Time      `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt   gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}&#10;&#10;type Paper struct {&#10;&#9;ID          uint           `gorm:&quot;primarykey&quot; json:&quot;id&quot;`&#10;&#9;Title       string         `gorm:&quot;type:varchar(255)&quot; json:&quot;title&quot;`&#10;&#9;CreatorID   uint          `json:&quot;creator_id&quot;`&#10;&#9;Questions   string         `gorm:&quot;type:text&quot; json:&quot;questions&quot;` // JSON格式存储题目ID列表&#10;&#9;Duration    int           `gorm:&quot;default:60&quot; json:&quot;duration&quot;`  // 考试时长（分钟）&#10;&#9;TotalScore  int           `json:&quot;total_score&quot;`&#10;&#9;CreatedAt   time.Time      `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt   time.Time      `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt   gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}&#10;&#10;type UserAnswer struct {&#10;&#9;ID         uint           `gorm:&quot;primarykey&quot; json:&quot;id&quot;`&#10;&#9;UserID     uint          `json:&quot;user_id&quot;`&#10;&#9;PaperID    uint          `json:&quot;paper_id&quot;`&#10;&#9;QuestionID uint          `json:&quot;question_id&quot;`&#10;&#9;Answer     string         `gorm:&quot;type:text&quot; json:&quot;answer&quot;`&#10;&#9;Score      int           `json:&quot;score&quot;`&#10;&#9;CreatedAt  time.Time      `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt  time.Time      `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt  gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/model/entity/user.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/model/entity/user.go" />
              <option name="updatedContent" value="package entity&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type Role string&#10;&#10;const (&#10;&#9;RoleUser    Role = &quot;user&quot;&#10;&#9;RoleTeacher Role = &quot;teacher&quot;&#10;&#9;RoleAdmin   Role = &quot;admin&quot;&#10;)&#10;&#10;type User struct {&#10;&#9;ID        uint           `gorm:&quot;primarykey&quot; json:&quot;id&quot;`&#10;&#9;Username  string         `gorm:&quot;type:varchar(50);uniqueIndex&quot; json:&quot;username&quot;`&#10;&#9;Password  string         `gorm:&quot;type:varchar(255)&quot; json:&quot;-&quot;`&#10;&#9;Role      Role          `gorm:&quot;type:enum('user','teacher','admin');default:'user'&quot; json:&quot;role&quot;`&#10;&#9;CreatedAt time.Time     `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt time.Time     `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/model/request/auth.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/model/request/auth.go" />
              <option name="updatedContent" value="package request&#10;&#10;type RegisterRequest struct {&#10;&#9;Username string `json:&quot;username&quot; binding:&quot;required,min=3,max=50&quot;`&#10;&#9;Password string `json:&quot;password&quot; binding:&quot;required,min=6&quot;`&#10;}&#10;&#10;type LoginRequest struct {&#10;&#9;Username string `json:&quot;username&quot; binding:&quot;required&quot;`&#10;&#9;Password string `json:&quot;password&quot; binding:&quot;required&quot;`&#10;}&#10;&#10;type LoginResponse struct {&#10;&#9;Token string `json:&quot;token&quot;`&#10;&#9;Role  string `json:&quot;role&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/model/request/question.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/model/request/question.go" />
              <option name="updatedContent" value="package request&#10;&#10;type CreateQuestionRequest struct {&#10;&#9;Title       string `json:&quot;title&quot; binding:&quot;required&quot;`&#10;&#9;Type        string `json:&quot;type&quot; binding:&quot;required&quot;`&#10;&#9;Difficulty  int    `json:&quot;difficulty&quot; binding:&quot;required,min=1,max=5&quot;`&#10;&#9;Options     string `json:&quot;options&quot;`&#10;&#9;Answer      string `json:&quot;answer&quot; binding:&quot;required&quot;`&#10;&#9;Explanation string `json:&quot;explanation&quot;`&#10;&#9;Tags        string `json:&quot;tags&quot;`&#10;}&#10;&#10;type UpdateQuestionRequest struct {&#10;&#9;Title       string `json:&quot;title&quot;`&#10;&#9;Difficulty  int    `json:&quot;difficulty&quot; binding:&quot;min=1,max=5&quot;`&#10;&#9;Options     string `json:&quot;options&quot;`&#10;&#9;Answer      string `json:&quot;answer&quot;`&#10;&#9;Explanation string `json:&quot;explanation&quot;`&#10;&#9;Tags        string `json:&quot;tags&quot;`&#10;}&#10;&#10;type CreatePaperRequest struct {&#10;&#9;Title      string `json:&quot;title&quot; binding:&quot;required&quot;`&#10;&#9;QuestionIDs []uint `json:&quot;question_ids&quot; binding:&quot;required&quot;`&#10;&#9;Duration   int    `json:&quot;duration&quot; binding:&quot;required,min=1&quot;`&#10;}&#10;&#10;type SubmitAnswerRequest struct {&#10;&#9;PaperID    uint   `json:&quot;paper_id&quot; binding:&quot;required&quot;`&#10;&#9;QuestionID uint   `json:&quot;question_id&quot; binding:&quot;required&quot;`&#10;&#9;Answer     string `json:&quot;answer&quot; binding:&quot;required&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/router/router.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/router/router.go" />
              <option name="updatedContent" value="package router&#10;&#10;import (&#10;&#9;&quot;testogo/internal/controller&quot;&#10;&#9;&quot;testogo/internal/middleware&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;func InitRouter(r *gin.Engine) {&#10;&#9;// 公共路由组&#10;&#9;public := r.Group(&quot;/api/v1&quot;)&#10;&#9;{&#10;&#9;&#9;// 认证相关路由&#10;&#9;&#9;auth := public.Group(&quot;/auth&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;auth.POST(&quot;/register&quot;, controller.Register)&#10;&#9;&#9;&#9;auth.POST(&quot;/login&quot;, controller.Login)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 需要认证的路由组&#10;&#9;protected := r.Group(&quot;/api/v1&quot;)&#10;&#9;protected.Use(middleware.AuthMiddleware())&#10;&#9;{&#10;&#9;&#9;// 题目相关路由&#10;&#9;&#9;questions := protected.Group(&quot;/questions&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;questions.GET(&quot;&quot;, controller.ListQuestions)&#10;&#9;&#9;&#9;questions.GET(&quot;/:id&quot;, controller.GetQuestion)&#10;&#9;&#9;&#9;questions.POST(&quot;&quot;, middleware.RoleMiddleware(&quot;teacher&quot;, &quot;admin&quot;), controller.CreateQuestion)&#10;&#9;&#9;&#9;questions.PUT(&quot;/:id&quot;, middleware.RoleMiddleware(&quot;teacher&quot;, &quot;admin&quot;), controller.UpdateQuestion)&#10;&#9;&#9;&#9;questions.DELETE(&quot;/:id&quot;, middleware.RoleMiddleware(&quot;teacher&quot;, &quot;admin&quot;), controller.DeleteQuestion)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 试卷相关路由&#10;&#9;&#9;papers := protected.Group(&quot;/papers&quot;)&#10;&#9;&#9;{&#10;&#9;&#9;&#9;papers.GET(&quot;&quot;, controller.ListPapers)&#10;&#9;&#9;&#9;papers.GET(&quot;/:id&quot;, controller.GetPaper)&#10;&#9;&#9;&#9;papers.POST(&quot;&quot;, middleware.RoleMiddleware(&quot;teacher&quot;, &quot;admin&quot;), controller.CreatePaper)&#10;&#9;&#9;&#9;papers.POST(&quot;/:id/submit&quot;, controller.SubmitPaper)&#10;&#9;&#9;&#9;papers.GET(&quot;/:id/result&quot;, controller.GetPaperResult)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 用户管理路由（仅管理员）&#10;&#9;&#9;users := protected.Group(&quot;/users&quot;)&#10;&#9;&#9;users.Use(middleware.RoleMiddleware(&quot;admin&quot;))&#10;&#9;&#9;{&#10;&#9;&#9;&#9;users.GET(&quot;&quot;, controller.ListUsers)&#10;&#9;&#9;&#9;users.PUT(&quot;/:id/role&quot;, controller.UpdateUserRole)&#10;&#9;&#9;&#9;users.DELETE(&quot;/:id&quot;, controller.DeleteUser)&#10;&#9;&#9;}&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.go" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;log&quot;&#10;&#9;&quot;testogo/internal/router&quot;&#10;&#9;&quot;testogo/pkg/config&quot;&#10;&#9;&quot;testogo/pkg/database&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;func main() {&#10;&#9;// 初始化配置&#10;&#9;if err := config.Init(); err != nil {&#10;&#9;&#9;log.Fatalf(&quot;配置初始化失败: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 初始化数据库&#10;&#9;if err := database.Init(); err != nil {&#10;&#9;&#9;log.Fatalf(&quot;数据库初始化失败: %v&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 创建 Gin 引擎&#10;&#9;app := gin.Default()&#10;&#10;&#9;// 初始化路由&#10;&#9;router.InitRouter(app)&#10;&#10;&#9;// 启动服务器&#10;&#9;port := config.GetString(&quot;server.port&quot;)&#10;&#9;if err := app.Run(&quot;:&quot; + port); err != nil {&#10;&#9;&#9;log.Fatalf(&quot;服务器启动失败: %v&quot;, err)&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pkg/config/config.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/config/config.go" />
              <option name="updatedContent" value="package config&#10;&#10;import &quot;github.com/spf13/viper&quot;&#10;&#10;func Init() error {&#10;&#9;viper.SetConfigName(&quot;config&quot;)&#10;&#9;viper.SetConfigType(&quot;yml&quot;)&#10;&#9;viper.AddConfigPath(&quot;./config&quot;)&#10;&#9;&#10;&#9;if err := viper.ReadInConfig(); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;&#10;&#9;return nil&#10;}&#10;&#10;func GetString(key string) string {&#10;&#9;return viper.GetString(key)&#10;}&#10;&#10;func GetInt(key string) int {&#10;&#9;return viper.GetInt(key)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pkg/database/database.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/database/database.go" />
              <option name="updatedContent" value="package database&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;testogo/pkg/config&quot;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#10;&#9;&quot;gorm.io/driver/mysql&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;var DB *gorm.DB&#10;&#10;func Init() error {&#10;&#9;dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?charset=%s&amp;parseTime=True&amp;loc=Local&quot;,&#10;&#9;&#9;config.GetString(&quot;database.username&quot;),&#10;&#9;&#9;config.GetString(&quot;database.password&quot;),&#10;&#9;&#9;config.GetString(&quot;database.host&quot;),&#10;&#9;&#9;config.GetInt(&quot;database.port&quot;),&#10;&#9;&#9;config.GetString(&quot;database.dbname&quot;),&#10;&#9;&#9;config.GetString(&quot;database.charset&quot;),&#10;&#9;)&#10;&#10;&#9;db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 设置连接池&#10;&#9;sqlDB, err := db.DB()&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;sqlDB.SetMaxIdleConns(config.GetInt(&quot;database.maxIdleConns&quot;))&#10;&#9;sqlDB.SetMaxOpenConns(config.GetInt(&quot;database.maxOpenConns&quot;))&#10;&#10;&#9;// 自动迁移数据库表&#10;&#9;err = db.AutoMigrate(&#10;&#9;&#9;&amp;entity.User{},&#10;&#9;&#9;&amp;entity.Question{},&#10;&#9;&#9;&amp;entity.Paper{},&#10;&#9;&#9;&amp;entity.UserAnswer{},&#10;&#9;)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;DB = db&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>