<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/internal/controller/paper.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/controller/paper.go" />
              <option name="originalContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#9;&quot;testogo/internal/model/request&quot;&#10;&#9;&quot;testogo/pkg/database&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;func CreatePaper(c *gin.Context) {&#10;&#9;var req request.CreatePaperRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 验证题目是否存在&#10;&#9;var count int64&#10;&#9;database.DB.Model(&amp;entity.Question{}).Where(&quot;id IN ?&quot;, req.QuestionIDs).Count(&amp;count)&#10;&#9;if int(count) != len(req.QuestionIDs) {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;包含不存在的题目&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 将题目ID列表转换为JSON字符串&#10;&#9;questionIDs, err := json.Marshal(req.QuestionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;题目列表序列化失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;paper := entity.Paper{&#10;&#9;&#9;Title:     req.Title,&#10;&#9;&#9;CreatorID: c.GetUint(&quot;userID&quot;),&#10;&#9;&#9;Questions: string(questionIDs),&#10;&#9;&#9;Duration:  req.Duration,&#10;&#9;}&#10;&#10;&#9;if err := database.DB.Create(&amp;paper).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;创建试卷失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;id&quot;: paper.ID})&#10;}&#10;&#10;func GetPaper(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var paper entity.Paper&#10;&#9;if err := database.DB.First(&amp;paper, id).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;试卷不存在&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 解析题目ID列表&#10;&#9;var questionIDs []uint&#10;&#9;if err := json.Unmarshal([]byte(paper.Questions), &amp;questionIDs); err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;解析题目列表失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 获取题目详情&#10;&#9;var questions []entity.Question&#10;&#9;if err := database.DB.Find(&amp;questions, questionIDs).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取题目详情失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;id&quot;:        paper.ID,&#10;&#9;&#9;&quot;title&quot;:     paper.Title,&#10;&#9;&#9;&quot;duration&quot;:  paper.Duration,&#10;&#9;&#9;&quot;questions&quot;: questions,&#10;&#9;})&#10;}&#10;&#10;func SubmitPaper(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;paperID, err := strconv.ParseUint(id, 10, 32)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;无效的试卷ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var answers []request.SubmitAnswerRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;answers); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;userID := c.GetUint(&quot;userID&quot;)&#10;&#9;var totalScore int&#10;&#10;&#9;// 开启事务&#10;&#9;tx := database.DB.Begin()&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;for _, answer := range answers {&#10;&#9;&#9;// 获取题目信息&#10;&#9;&#9;var question entity.Question&#10;&#9;&#9;if err := tx.First(&amp;question, answer.QuestionID).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;题目不存在&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 计算得分&#10;&#9;&#9;score := 0&#10;&#9;&#9;if question.Answer == answer.Answer {&#10;&#9;&#9;&#9;score = 10 // 每题10分&#10;&#9;&#9;}&#10;&#9;&#9;totalScore += score&#10;&#10;&#9;&#9;// 保存答题记录&#10;&#9;&#9;userAnswer := entity.UserAnswer{&#10;&#9;&#9;&#9;UserID:     userID,&#10;&#9;&#9;&#9;PaperID:    uint(paperID),&#10;&#9;&#9;&#9;QuestionID: answer.QuestionID,&#10;&#9;&#9;&#9;Answer:     answer.Answer,&#10;&#9;&#9;&#9;Score:      score,&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := tx.Create(&amp;userAnswer).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;保存答题记录失败&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err := tx.Commit().Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;提交试卷失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;提交成功&quot;,&#10;&#9;&#9;&quot;score&quot;:   totalScore,&#10;&#9;})&#10;}&#10;&#10;func GetPaperResult(c *gin.Context) {&#10;&#9;paperID := c.Param(&quot;id&quot;)&#10;&#9;userID := c.GetUint(&quot;userID&quot;)&#10;&#10;&#9;var answers []entity.UserAnswer&#10;&#9;if err := database.DB.Where(&quot;user_id = ? AND paper_id = ?&quot;, userID, paperID).Find(&amp;answers).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取答题记录失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;totalScore := 0&#10;&#9;for _, answer := range answers {&#10;&#9;&#9;totalScore += answer.Score&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;answers&quot;:    answers,&#10;&#9;&#9;&quot;totalScore&quot;: totalScore,&#10;&#9;})&#10;}&#10;" />
              <option name="updatedContent" value="package controller&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;strconv&quot;&#10;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#9;&quot;testogo/internal/model/request&quot;&#10;&#9;&quot;testogo/pkg/database&quot;&#10;&#10;&#9;&quot;github.com/gin-gonic/gin&quot;&#10;)&#10;&#10;func CreatePaper(c *gin.Context) {&#10;&#9;var req request.CreatePaperRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;req); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 验证题目是否存在&#10;&#9;var count int64&#10;&#9;database.DB.Model(&amp;entity.Question{}).Where(&quot;id IN ?&quot;, req.QuestionIDs).Count(&amp;count)&#10;&#9;if int(count) != len(req.QuestionIDs) {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;包含不存在的题目&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 将题目ID列表转换为JSON字符串&#10;&#9;questionIDs, err := json.Marshal(req.QuestionIDs)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;题目列表序列化失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;paper := entity.Paper{&#10;&#9;&#9;Title:     req.Title,&#10;&#9;&#9;CreatorID: c.GetUint(&quot;userID&quot;),&#10;&#9;&#9;Questions: string(questionIDs),&#10;&#9;&#9;Duration:  req.Duration,&#10;&#9;}&#10;&#10;&#9;if err := database.DB.Create(&amp;paper).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;创建试卷失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;id&quot;: paper.ID})&#10;}&#10;&#10;func GetPaper(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;var paper entity.Paper&#10;&#9;if err := database.DB.First(&amp;paper, id).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusNotFound, gin.H{&quot;error&quot;: &quot;试卷不存在&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 解析题目ID列表&#10;&#9;var questionIDs []uint&#10;&#9;if err := json.Unmarshal([]byte(paper.Questions), &amp;questionIDs); err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;解析题目列表失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;// 获取题目详情&#10;&#9;var questions []entity.Question&#10;&#9;if err := database.DB.Find(&amp;questions, questionIDs).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取题目详情失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;id&quot;:        paper.ID,&#10;&#9;&#9;&quot;title&quot;:     paper.Title,&#10;&#9;&#9;&quot;duration&quot;:  paper.Duration,&#10;&#9;&#9;&quot;questions&quot;: questions,&#10;&#9;})&#10;}&#10;&#10;func SubmitPaper(c *gin.Context) {&#10;&#9;id := c.Param(&quot;id&quot;)&#10;&#9;paperID, err := strconv.ParseUint(id, 10, 32)&#10;&#9;if err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;无效的试卷ID&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;var answers []request.SubmitAnswerRequest&#10;&#9;if err := c.ShouldBindJSON(&amp;answers); err != nil {&#10;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;userID := c.GetUint(&quot;userID&quot;)&#10;&#9;var totalScore int&#10;&#10;&#9;// 开启事务&#10;&#9;tx := database.DB.Begin()&#10;&#9;defer func() {&#10;&#9;&#9;if r := recover(); r != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;for _, answer := range answers {&#10;&#9;&#9;// 获取题目信息&#10;&#9;&#9;var question entity.Question&#10;&#9;&#9;if err := tx.First(&amp;question, answer.QuestionID).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: &quot;题目不存在&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 计算得分&#10;&#9;&#9;score := 0&#10;&#9;&#9;if question.Answer == answer.Answer {&#10;&#9;&#9;&#9;score = 10 // 每题10分&#10;&#9;&#9;}&#10;&#9;&#9;totalScore += score&#10;&#10;&#9;&#9;// 保存答题记录&#10;&#9;&#9;userAnswer := entity.UserAnswer{&#10;&#9;&#9;&#9;UserID:     userID,&#10;&#9;&#9;&#9;PaperID:    uint(paperID),&#10;&#9;&#9;&#9;QuestionID: answer.QuestionID,&#10;&#9;&#9;&#9;Answer:     answer.Answer,&#10;&#9;&#9;&#9;Score:      score,&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if err := tx.Create(&amp;userAnswer).Error; err != nil {&#10;&#9;&#9;&#9;tx.Rollback()&#10;&#9;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;保存答题记录失败&quot;})&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err := tx.Commit().Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;提交试卷失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;message&quot;: &quot;提交成功&quot;,&#10;&#9;&#9;&quot;score&quot;:   totalScore,&#10;&#9;})&#10;}&#10;&#10;func GetPaperResult(c *gin.Context) {&#10;&#9;paperID := c.Param(&quot;id&quot;)&#10;&#9;userID := c.GetUint(&quot;userID&quot;)&#10;&#10;&#9;var answers []entity.UserAnswer&#10;&#9;if err := database.DB.Where(&quot;user_id = ? AND paper_id = ?&quot;, userID, paperID).Find(&amp;answers).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取答题记录失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;totalScore := 0&#10;&#9;for _, answer := range answers {&#10;&#9;&#9;totalScore += answer.Score&#10;&#9;}&#10;&#10;&#9;c.JSON(http.StatusOK, gin.H{&#10;&#9;&#9;&quot;answers&quot;:    answers,&#10;&#9;&#9;&quot;totalScore&quot;: totalScore,&#10;&#9;})&#10;}&#10;&#10;func ListPapers(c *gin.Context) {&#10;&#9;var papers []entity.Paper&#10;&#9;if err := database.DB.Find(&amp;papers).Error; err != nil {&#10;&#9;&#9;c.JSON(http.StatusInternalServerError, gin.H{&quot;error&quot;: &quot;获取试卷列表失败&quot;})&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;c.JSON(http.StatusOK, gin.H{&quot;papers&quot;: papers})&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/model/entity/paper.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/model/entity/paper.go" />
              <option name="updatedContent" value="package entity&#10;&#10;import (&#10;&#9;&quot;gorm.io/gorm&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;type Paper struct {&#10;&#9;ID        uint           `gorm:&quot;primaryKey&quot; json:&quot;id&quot;`&#10;&#9;Title     string         `json:&quot;title&quot;`&#10;&#9;CreatorID uint           `json:&quot;creator_id&quot;`&#10;&#9;Questions string         `json:&quot;questions&quot;` // 题目ID的JSON字符串&#10;&#9;Duration  int            `json:&quot;duration&quot;`  // 单位：分钟&#10;&#9;CreatedAt time.Time      `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt time.Time      `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/model/entity/question.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/model/entity/question.go" />
              <option name="originalContent" value="package entity&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type QuestionType string&#10;&#10;const (&#10;&#9;TypeChoice QuestionType = &quot;choice&quot; // 选择题&#10;&#9;TypeJudge  QuestionType = &quot;judge&quot;  // 判断题&#10;&#9;TypeFillIn QuestionType = &quot;fillin&quot; // 填空题&#10;&#9;TypeMath   QuestionType = &quot;math&quot;   // 加减法题&#10;)&#10;&#10;type Question struct {&#10;&#9;ID          uint           `gorm:&quot;primarykey&quot; json:&quot;id&quot;`&#10;&#9;Title       string         `gorm:&quot;type:text&quot; json:&quot;title&quot;`&#10;&#9;Type        QuestionType   `gorm:&quot;type:varchar(20)&quot; json:&quot;type&quot;`&#10;&#9;Difficulty  int            `gorm:&quot;type:tinyint;default:1&quot; json:&quot;difficulty&quot;` // 1-5&#10;&#9;Options     string         `gorm:&quot;type:text&quot; json:&quot;options&quot;`                 // JSON格式存储选项&#10;&#9;Answer      string         `gorm:&quot;type:text&quot; json:&quot;answer&quot;`&#10;&#9;Explanation string         `gorm:&quot;type:text&quot; json:&quot;explanation&quot;` // 答案解释&#10;&#9;CreatorID   uint           `json:&quot;creator_id&quot;`&#10;&#9;MediaURL    string         `gorm:&quot;type:varchar(255)&quot; json:&quot;media_url&quot;` // 媒体资源URL&#10;&#9;Tags        string         `gorm:&quot;type:varchar(255)&quot; json:&quot;tags&quot;`      // 逗号分隔的标签&#10;&#9;CreatedAt   time.Time      `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt   time.Time      `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt   gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}&#10;&#10;type Paper struct {&#10;&#9;ID         uint           `gorm:&quot;primarykey&quot; json:&quot;id&quot;`&#10;&#9;Title      string         `gorm:&quot;type:varchar(255)&quot; json:&quot;title&quot;`&#10;&#9;CreatorID  uint           `json:&quot;creator_id&quot;`&#10;&#9;Questions  string         `gorm:&quot;type:text&quot; json:&quot;questions&quot;` // JSON格式存储题目ID列表&#10;&#9;Duration   int            `gorm:&quot;default:60&quot; json:&quot;duration&quot;` // 考试时长（分钟）&#10;&#9;TotalScore int            `json:&quot;total_score&quot;`&#10;&#9;CreatedAt  time.Time      `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt  time.Time      `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt  gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}&#10;&#10;type UserAnswer struct {&#10;&#9;ID         uint           `gorm:&quot;primarykey&quot; json:&quot;id&quot;`&#10;&#9;UserID     uint           `json:&quot;user_id&quot;`&#10;&#9;PaperID    uint           `json:&quot;paper_id&quot;`&#10;&#9;QuestionID uint           `json:&quot;question_id&quot;`&#10;&#9;Answer     string         `gorm:&quot;type:text&quot; json:&quot;answer&quot;`&#10;&#9;Score      int            `json:&quot;score&quot;`&#10;&#9;CreatedAt  time.Time      `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt  time.Time      `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt  gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}&#10;" />
              <option name="updatedContent" value="package entity&#10;&#10;import (&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;type QuestionType string&#10;&#10;const (&#10;&#9;TypeChoice QuestionType = &quot;choice&quot; // 选择题&#10;&#9;TypeJudge  QuestionType = &quot;judge&quot;  // 判断题&#10;&#9;TypeFillIn QuestionType = &quot;fillin&quot; // 填空题&#10;&#9;TypeMath   QuestionType = &quot;math&quot;   // 加减法题&#10;)&#10;&#10;type Question struct {&#10;&#9;ID          uint           `gorm:&quot;primarykey&quot; json:&quot;id&quot;`&#10;&#9;Title       string         `gorm:&quot;type:text&quot; json:&quot;title&quot;`&#10;&#9;Type        QuestionType   `gorm:&quot;type:varchar(20)&quot; json:&quot;type&quot;`&#10;&#9;Difficulty  int            `gorm:&quot;type:tinyint;default:1&quot; json:&quot;difficulty&quot;` // 1-5&#10;&#9;Options     string         `gorm:&quot;type:text&quot; json:&quot;options&quot;`                 // JSON格式存储选项&#10;&#9;Answer      string         `gorm:&quot;type:text&quot; json:&quot;answer&quot;`&#10;&#9;Explanation string         `gorm:&quot;type:text&quot; json:&quot;explanation&quot;` // 答案解释&#10;&#9;CreatorID   uint           `json:&quot;creator_id&quot;`&#10;&#9;MediaURL    string         `gorm:&quot;type:varchar(255)&quot; json:&quot;media_url&quot;` // 媒体资源URL&#10;&#9;Tags        string         `gorm:&quot;type:varchar(255)&quot; json:&quot;tags&quot;`      // 逗号分隔的标签&#10;&#9;CreatedAt   time.Time      `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt   time.Time      `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt   gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}&#10;&#10;type UserAnswer struct {&#10;&#9;ID         uint           `gorm:&quot;primarykey&quot; json:&quot;id&quot;`&#10;&#9;UserID     uint           `json:&quot;user_id&quot;`&#10;&#9;PaperID    uint           `json:&quot;paper_id&quot;`&#10;&#9;QuestionID uint           `json:&quot;question_id&quot;`&#10;&#9;Answer     string         `gorm:&quot;type:text&quot; json:&quot;answer&quot;`&#10;&#9;Score      int            `json:&quot;score&quot;`&#10;&#9;CreatedAt  time.Time      `json:&quot;created_at&quot;`&#10;&#9;UpdatedAt  time.Time      `json:&quot;updated_at&quot;`&#10;&#9;DeletedAt  gorm.DeletedAt `gorm:&quot;index&quot; json:&quot;-&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pkg/database/database.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pkg/database/database.go" />
              <option name="originalContent" value="package database&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#9;&quot;testogo/pkg/config&quot;&#10;&#10;&#9;&quot;gorm.io/driver/mysql&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;)&#10;&#10;var DB *gorm.DB&#10;&#10;func Init() error {&#10;&#9;dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?charset=%s&amp;parseTime=True&amp;loc=Local&quot;,&#10;&#9;&#9;config.GetString(&quot;database.username&quot;),&#10;&#9;&#9;config.GetString(&quot;database.password&quot;),&#10;&#9;&#9;config.GetString(&quot;database.host&quot;),&#10;&#9;&#9;config.GetInt(&quot;database.port&quot;),&#10;&#9;&#9;config.GetString(&quot;database.dbname&quot;),&#10;&#9;&#9;config.GetString(&quot;database.charset&quot;),&#10;&#9;)&#10;&#10;&#9;db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 设置连接池&#10;&#9;sqlDB, err := db.DB()&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;sqlDB.SetMaxIdleConns(config.GetInt(&quot;database.maxIdleConns&quot;))&#10;&#9;sqlDB.SetMaxOpenConns(config.GetInt(&quot;database.maxOpenConns&quot;))&#10;&#10;&#9;// 自动迁移数据库表&#10;&#9;err = db.AutoMigrate(&#10;&#9;&#9;&amp;entity.User{},&#10;&#9;&#9;&amp;entity.Question{},&#10;&#9;&#9;&amp;entity.Paper{},&#10;&#9;&#9;&amp;entity.UserAnswer{},&#10;&#9;)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;DB = db&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package database&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;testogo/internal/model/entity&quot;&#10;&#9;&quot;testogo/pkg/config&quot;&#10;&#10;&#9;&quot;gorm.io/driver/mysql&quot;&#10;&#9;&quot;gorm.io/gorm&quot;&#10;&#9;&quot;gorm.io/gorm/schema&quot;&#10;)&#10;&#10;var DB *gorm.DB&#10;&#10;func Init() error {&#10;&#9;dsn := fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)/%s?charset=%s&amp;parseTime=True&amp;loc=Local&amp;timeout=10s&amp;writeTimeout=30s&amp;readTimeout=30s&quot;,&#10;&#9;&#9;config.GetString(&quot;database.username&quot;),&#10;&#9;&#9;config.GetString(&quot;database.password&quot;),&#10;&#9;&#9;config.GetString(&quot;database.host&quot;),&#10;&#9;&#9;config.GetInt(&quot;database.port&quot;),&#10;&#9;&#9;config.GetString(&quot;database.dbname&quot;),&#10;&#9;&#9;config.GetString(&quot;database.charset&quot;),&#10;&#9;)&#10;&#10;&#9;db, err := gorm.Open(mysql.New(mysql.Config{&#10;&#9;&#9;DSN: dsn,&#10;&#9;&#9;DefaultStringSize: 191, // MySQL 5.7 的 utf8mb4 索引长度限制&#10;&#9;}), &amp;gorm.Config{&#10;&#9;&#9;NamingStrategy: schema.NamingStrategy{&#10;&#9;&#9;&#9;SingularTable: true, // 使用单数表名&#10;&#9;&#9;},&#10;&#9;&#9;DisableForeignKeyConstraintWhenMigrating: true, // 禁用外键约束&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 设置连接池&#10;&#9;sqlDB, err := db.DB()&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;sqlDB.SetMaxIdleConns(config.GetInt(&quot;database.maxIdleConns&quot;))&#10;&#9;sqlDB.SetMaxOpenConns(config.GetInt(&quot;database.maxOpenConns&quot;))&#10;&#9;sqlDB.SetConnMaxLifetime(time.Hour) // 设置连接最大生命周期&#10;&#10;&#9;// 自动迁移数据库表&#10;&#9;err = db.AutoMigrate(&#10;&#9;&#9;&amp;entity.User{},&#10;&#9;&#9;&amp;entity.Question{},&#10;&#9;&#9;&amp;entity.Paper{},&#10;&#9;&#9;&amp;entity.UserAnswer{},&#10;&#9;)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;DB = db&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>